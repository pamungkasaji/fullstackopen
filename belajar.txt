> npx create-react-app part1
> cd part1
> npm start

belu paham
- (event) parameter
- Promises, promise chaining

console warning :
https://stackoverflow.com/a/61442974/12250944

https://reactjs.org/docs/introducing-jsx.html

https://reactjs.org/docs/components-and-props.html

[ PART 1 ]
c. Component state, event handlers
   Complex state
      const [clicks, setClicks] = useState({
         left: 0, right: 0
      })
      const handleLeftClick = () =>
         setClicks({ ...clicks, left: clicks.left + 1 })
   Handling arrays state
      const [allClicks, setAll] = useState([])
      setAll(allClicks.concat('L'))
   Conditional rendering
   Old React
      we use the state hook to add state to our React components
      Before the addition of hooks, there was no way to add state to functional components
   Debugging React applications
      Keep the browser's developer console open at all times.
      add the React developer tools extension to add Components tab
   Rules of Hooks
      useState function and useEffect must not be called from inside of a loop, a conditional expression, or any place that is not a function defining a component
      hooks may only be called from the inside of a function body that defines a React component
   Event Handling Revisited
   Function that returns a function
      //state
      const [value, setValue] = useState(10)
      //the function
      const setToValue = (newValue) => () => {
         setValue(newValue)   }
      //event handler
      <button onClick={setToValue(0)}>reset</button>
   Passing Event Handlers to Child Components
      for example, by extracting the button into its own component
         <button onClick={props.handleClick}>   {props.text}   </button>
   Do Not Define Components Within Components
      The application still appears to work, but never define components inside of other components
	Useful Reading
   Excercise
      nice excercise
      most votes belum

[PART 2]
a. Rendering a collection, modules
   JavaScript Arrays
      functional programming methods of the JavaScript array, such as find, filter, and map
      https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84
      https://www.youtube.com/watch?v=-LFjnY1PEDA
   Rendering collections
      use map
   Key-attribute
      the elements generated by the map method, must each have a unique attribute called key
      <ul>
        {notes.map(note => 
          <li key={note.id}>  {note.content} </li>                  
        )}
      </ul>
   Map: map always creates a new array      
   Anti-pattern: don't use array indexes as keys 
   Refactoring modules
      Create a separate Note component, and define the key attribute for the Note components, and not for the li tags
      Common practice for building React app is to declare each component in their own file as an ES6-module
         add "export default Note" at the end of Note component file
         to import in index.js: import Note from './components/Note'
   When the application breaks
      Dynamically typed languages, such as JavaScript, where the compiler does not check the data type of, for instance, function variables or return values
      Use console.log for debugging
   Excercise

b. Forms
   expanding Note application by allowing users to add new notes
   Filtering Displayed Elements
      conditional operator
   Exercises: Phonebook
      template string

c. Getting data from server
         Create a file named db.json in the root directory of the project
         > npx json-server --port 3001 --watch db.json
      The browser as a runtime environment
         In Java the code executes line by line and stops to wait for the HTTP request
         JavaScript engines, or runtime environments, follow the asynchronous model
            this requires all IO-operations (with some exceptions) to be executed as non-blocking
            the code execution continues immediately after calling an IO function, without waiting for it to return
            When an asynchronous operation is completed, the JavaScript engine calls the event handlers registered to the operation
            Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel
               As a result, it is a requirement in practice to use a non-blocking model for executing IO operations
               Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server.
               Another consequence of this single-threaded nature of JavaScript engines is that if some code execution takes up a lot of time, the browser will get stuck for the duration of the execution
      npm
         JavaScript projects are defined using the node package manager, aka npm
         > npm install axios
         npm-commands should always be run in the project root directory,where the package.json file can be found
         > npm install json-server --save-dev
            adding "server" to package.json
            > npm run server
            To run json-server and your react app simultaneously, you may need to use two terminal windows. One to keep json-server running and the other to run react-app.
      Axios and promises
         A Promise is an object representing the eventual completion or failure of an asynchronous operation.
         A promise can have three distinct states: pending, fulfiled, rejected
         const promise = axios.get('http://localhost:3001/notes')
            to access the result of the operation represented by the promise, we must register an event handler to the promise
            axios.get('http://localhost:3001/notes').then(response => {
               const notes = response.data
               console.log(notes)   })
      Effect-hooks
         The Effect Hook lets you perform side effects in function components.
         Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.
         penjelasan proses fetching data dari server
            Understanding the order of events is critical!
      The development runtime environment
      Exercise skip dulu
d. Altering data in server
   REST
   Sending Data to the Server
   Changing the importance of notes
   Extracting communication with the backend into a separate module
      single responsibility principle
      create a src/services directory and add a file there called notes.js
      Promises are central to modern JavaScript development
   Cleaner syntax for defining object literals
   Promises and errors
      common way of adding a handler for rejected promises is to use the catch method
      When our application makes an HTTP request, we are in fact creating a promise chain:
      The catch method can be used to define a handler function at the end of a promise chain
e. Adding styles to React app
   CSS
   Improved error message
   Inline styles
      Any React component or element can be provided with a set of CSS properties as a JavaScript object through the style attribute
      CSS rules are defined slightly differently in JavaScript than in normal CSS files
      CSS properties are written in camelCase
      Inline styles and some of the other ways of adding styles to React components go completely against the grain of old conventions
         Traditionally, it has been considered the best practice to entirely separate CSS from the content (HTML) and functionality (JavaScript)
         The philosophy of React is, in fact, the polar opposite of this.
         Since the separation of CSS, HTML, and JavaScript into separate files did not seem to scale well in larger applications
            React bases the division of the application along the lines of its logical functional entities
               The structural units that make up the application's functional entities are React components
               A React component defines the HTML for structuring the content
               the JavaScript functions for determining functionality, and also the component's styling; all in one place
               This is to create individual components that are as independent and reusable as possible.

[PART 3]
a. Node.js and Express
      We will be building our backend on top of NodeJS, which is a JavaScript runtime based on Google's Chrome V8 JavaScript engine
      > npm init
         automatically generated package.json file at the root of the project, that contains information about the project.
   Simple web server
   Express
      Many libraries have been developed to ease server side development with Node
      These libraries aim to provide a better abstraction for general use cases we usually require to build a backend server
      By far the most popular library intended for this purpose is express.
      > npm install express
      The versioning model used in npm is called semantic versioning.
      We can update the dependencies of the project with the command:
         > npm update
      Likewise, if we start working on the project on another computer, we can install all up-to-date dependencies of the project defined in package.json with a command :
         > npm install
   Web and express
      With express, transformation to JSON format happens automatically
      JSON is a string, and not a JavaScript object like the value assigned to notes
   nodemon
      If we make changes to the application's code we have to restart the application in order to see the changes, unlike the convenient workflow in React
         The solution to this problem is nodemon
      nodemon will watch the files in the directory in which nodemon was started, and if any files change, nodemon will automatically restart your node application.
      Let's install nodemon by defining it as a development dependency with the command:
         > npm install --save-dev nodemon
      By development dependencies, we are referring to tools that are needed only during the development of the application, e.g. for testing or automatically restarting the application
      These development dependencies are not needed when the application is run in production mode on the production server (e.g. Heroku).
         change script and run 
            > npm run dev
      even though the backend server restarts automatically, the browser still has to be manually refreshed
   REST
      REST is an architectural style meant for building scalable web applications.
   Fetching a single resource
      In JavaScript, the "triple equals" comparison === considers all values of different types to not be equal by default, meaning that 1 is not '1'.
         changing the id parameter found in request.params.id from a string into a number:
            const id = Number(request.params.id)
      If no note is found, the server should respond with the status code 404 not found instead of 200
   Deleting resources
      Deletion happens by making an HTTP DELETE request to the url of the resource
      If deleting the resource is successful, we respond to the request with the status code 204 no content
   Postman
      Many tools exist for making the testing of backends easier. One of these is a command line program curl
      However, instead of curl, we will take a look at using Postman for testing the application.
   The Visual Studio Code REST client
      you can use the VS Code REST client plugin instead of Postman.
      We save all the REST client requests in the directory as files that end with the .rest extension
   Receiving data
      Adding a note happens by making an HTTP POST request
      In order to access the data easily, we need the help of the express json-parser
         that is taken to use with command app.use(express.json()).
         Without the json-parser, the body property would be undefined
         The json-parser takes the JSON data of a request, transforms it into a JS object and attaches it to the body property of the request object
      Dont forget to change Content-type
      it is better to generate timestamps on the server than in the browser 
   About HTTP request types
      The HTTP standard talks about two properties related to request types, safety and idempotence.
      Safe : GET and HEAD
         Safety means that the executing request must not cause any side effects in the server
      Idempotent : GET, HEAD, PUT and DELETE share this property ?
   Middleware
      The express json-parser we took into use earlier is a so-called middleware.
      Middleware are functions that can be used for handling request and response objects.
      Middleware is a function that receives three parameters:
      we can use several middleware at the same time
      Middleware functions are called in the order that they're taken into use with the express server object's use method
      Middleware can be called before and after routes
         unknownEndpoint called after routes, if unknown endpoint was given by client
      http://expressjs.com/en/guide/using-middleware.html

b. Deploying app to internet     
   Same origin policy and CORS
      Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources (e.g. fonts) on a web page to be requested from another domain
      by default, the JavaScript code of an application that runs in a browser can only communicate with a server in the same origin.
         Because our server is in localhost port 3001, and our frontend in localhost port 3000, they do not have the same origin.
      same origin policy and CORS are not specific to React or Node
      We can allow requests from other origins by using Node's cors middleware.
         > npm install cors
      take the middleware to use and allow for requests from all origins:
   Application to the Internet
      let's move our application to the internet using Heroku
      install heroku, login first. Then follow instruction
      push issue : https://stackoverflow.com/a/34573866/12250944
      https://stark-ravine-43458.herokuapp.com/api/notes
   Frontend production build
      So far we have been running React code in development mode         
         In development mode the application is configured to give clear error messages, immediately render code changes to the browser, and so on.
      When the application is deployed, we must create a production build or a version of the application which is optimized for production.
         > npm run build
         This creates a directory called build (which contains the only HTML file of our application, index.html ) which contains the directory static
         Minified version of our application's JavaScript code will be generated to the static directory
         Even though the application code is in multiple files, all of the JavaScript will be minified into one file
      Serving static files from the backend
         One option for deploying the frontend is to copy the production build (the build directory) to the root of the backend repository ...
         if both the frontend and the backend are at the same address, we can declare baseUrl as a relative URL
         copy build in frontend to backend. commit and push backend to heroku
         https://stark-ravine-43458.herokuapp.com/
         Our application saves the notes to a variable. If the application crashes or is restarted, all of the data will disappear. It needs a database
      Streamlining deploying of the frontend
         add some npm-scripts to the package.json of the backend repository
      Proxy
         ?
c. Saving data to MongoDB
   Debugging Node applications
      Printing to the console is always worth doing
      The Visual Studio Code debugger can be useful in some situations.
         Click Run -> start debugging on VS Code
      Chrome dev tools
         Debugging is also possible with the Chrome developer console by starting your application with the command:
            node --inspect index.js
      Question everything
         there will be many potential areas for bugs in the application.
         When the application "does not work", we have to first figure out where the problem actually occurs
         The key is to be systematic. Since the problem can exist anywhere, you must question everything, and eliminate all possibilities one by one
            Logging to the console, Postman, debuggers, and experience will help.
         When bugs occur, the worst of all possible strategies is to continue writing code
            It will guarantee that your code will soon have even more bugs, and debugging them will be even more difficult.
   MongoDB
      In this course we will use MongoDB which is a so-called document database.
      Document databases differ from relational databases in how they organize data as well as the query languages they support.
      Document databases are usually categorized under the NoSQL umbrella term.
      MongoDB Atlas: database service for MongoDB
         create organization and create project on mangodb web first
         create a starter cluster for free
         add user for database access
            username : notesapp, pass : passdbnotesapp
         follow instruction ...
      use Mongoose as an object document mapper (ODM), and saving JavaScript objects as Mongo documents
         > node mongo.js passdbnotesapp
   Schema
      After establishing the connection to the database, we define the schema for a note and the matching model:
   Creating and saving objects
   Fetching objects from the database
      The objects are retrieved from the database with the find method of the Note mode
   Backend connected to a database
   Database configuration into its own module
      create a new directory for the module called models, and add a file called note.js
      There are many ways to define the value of an environment variable
      It's not a good idea to hardcode the address of the database into the code
         so instead the address of the database is passed to the application via the MONGODB_URI environment variable.
         There are many ways to define the value of an environment variable
            A more sophisticated way is to use the dotenv library
            > npm install dotenv
   Using database in route handlers
      Creating a new note and save it to db
      use Mongoose's findById method to fetch an individual note 
   Verifying frontend and backend integration
      get and post note work fine
   Error handling
      When dealing with Promises, it's almost always a good idea to add error and exception handling, 
         because otherwise you will find yourself dealing with strange bugs
   Moving error handling into middleware
      But there are cases where it is better to implement all error handling in a single place
         This can be useful if we later on want to report data related to errors to an external error tracking system like Sentry
   The order of middleware loading
      The execution order of middleware is the same as the order that they are loaded into express with the app.use function.
      The json-parser middleware should be among the very first middleware loaded into Express
      middleware for handling unsupported routes is next to the last middleware that is loaded into Express, just before the error handler
   Other operations
      add deleting and updating an individual note functionality 
      The easiest way to delete a note from the database is with the findByIdAndRemove method
      update uses findByIdAndUpdate method
         By default, the updatedNote parameter of the event handler receives the original document
         We added the optional { new: true }parameter, which will cause our event handler to be called with the new modified document instead of the original.

d. Validation and ESLint
         There are usually constraints that we want to apply to the data that is stored in our application's database. 
         One way of validating the format of the data is to use the validation functionality available in Mongoose.
         COBA VALIDATION, BELUM BERHASIL
      Promise chaining
         Promise chaining provides much benefit if there were many asynchronous operations that had to be done in sequence using async/await syntax in JavaScript
      Deploying the database backend to production
         heroku config:set doesn't work
         https://stackoverflow.com/questions/55876225/cant-connect-to-mongodb-using-environment-variable-for-heroku
      Lint
         lint or a linter is any tool that detects and flags errors in programming languages, including stylistic errors
         Lint-like tools generally perform static analysis of source code.
         Let's install ESlint as a development dependency to the backend project 
            > npm install eslint --save-dev
            > npx eslint --init
            The configuration will be saved in the .eslintrc.js file
         https://eslint.org/docs/rules/
         Many companies define coding standards that are enforced throughout the organization through the ESlint configuration file.
         it can be a good idea to adopt a ready-made configuration from someone else's project into yours.
         Recently many projects have adopted the Airbnb Javascript style guide by taking Airbnb's ESlint configuration into use

[PART 4]
a. Structure of backend application, introduction to testing
      Project structure
         modify the structure of our project to adhere to Node.js best practices.
         separate all printing to the console to its own module utils/logger.js
         The index.js file only imports the actual application from the app.js file and then starts the application.
         The handling of environment variables is extracted into a separate utils/config.js file
         The route handlers have also been moved into a dedicated module (controllers).
            All of the routes related to notes are now in the notes.js module under the controllers directory.
         A router object is an isolated instance of middleware and routes.
         The app.js file that creates the actual application, takes different middleware into use
         custom middleware has been moved to a new utils/middleware.js module
         The responsibility of establishing the connection to the database has been given to the app.js
         The note.js file under the models directory only defines the Mongoose schema for notes
         Once the application starts to grow in size, you are going to have to establish some kind of structure
            and separate the different responsibilities of the application into separate modules
      Testing Node applications
         one essential area of software development is automated testing
         we will be using a testing library developed and used internally by Facebook called jest
         Jest is a natural choice for this course, as it works well for testing backends, and it shines when it comes to testing React applications.
         install jest as a development dependency
            > npm install --save-dev jest
         Individual test cases are defined with the test function
         run the test using command:
            > npm test
            Jest expects by default that the names of test files contain .test
         Describe blocks can be used for grouping tests into logical collections

b. Testing the backend
         Since the backend does not contain any complicated logic, it doesn't make sense to write unit tests for it
         The only potential thing we could unit test is the toJSON method that is used for formatting notes.
         it can be beneficial to implement some of the backend tests by mocking the database instead of using a real database
            One library that could be used for this is mongo-mock.
         Since our application's backend is simple, we willtest the entire application through its REST API, so that the database is also included
            This kind of testing where multiple components of the system are being tested as a group, is called integration testing.
      Test environment
         when your backend server is running in Heroku, it is in production mode.
         > npm install --save-dev cross-env
         We can create our separate test database in Mongo DB Atlas.
            This is not an optimal solution in situations where there are many people developing the same application. 
            It would be better to run our tests using a database that is installed and running in the developer's local machine. 
            This is "relatively simple" to achieve by running Mongo in-memory or by using Docker containers.
            We will not complicate things and will instead continue to use the MongoDB Atlas database.
         We specified the mode of the application to be development in the npm run dev script that uses nodemon.
         We also specified that the default npm start command will define the mode as production.
      supertest
         use the supertest package to help us write our tests for testing the API.
         async/await syntax is related to the fact that making a request to the API is an asynchronous operation
      Initializing the database before tests
         In order to make our tests more robust, we have to reset the database and generate the needed test data in a controlled manner before we run the tests
         Our tests are already using the afterAll function of Jest to close the connection to the database after the tests are finished executing
         initialize the database before every test with the beforeEach function
      Running tests one by one
         > npm test -- tests/note_api.test.js
         > npm test -- -t 'a specific note is within the returned notes'
      async/await
         async/await syntax makes it possible to use asynchronous functions that return a promise in a way that makes the code look synchronous
         read explanation in course
         In order to use the await operator with asynchronous operations, they have to return a promise
         The await keyword can't be used just anywhere in JavaScript code.
            Using await is possible only inside of an async function.
      async/await in the backend
         change the route handler functions into async functions.
      More tests and refactoring the backend
         When code gets refactored, there is a risk of regression, meaning that existing functionality may break
         The code using promises works and the tests pass. We are ready to refactor our code to use the async/await syntax.
      Error handling and async/await
         With async/await the recommended way of dealing with exceptions is the old and familiar try/catch mechanism
         The catch block simply calls the next function, which passes the request handling to the error handling middleware.
      Eliminating the try-catch
         The express-async-errors library has a solution for refactoring the code to eliminate the catch from the methods
            > npm install express-async-errors
            the library allows us to eliminate the try-catch blocks completely
            Because of the library, we do not need the next(exception) call anymore
            If an exception occurs in a async route, the execution is automatically passed to the error handling middleware.
      Optimizing the beforeEach function
         a better way of saving multiple objects to the database
         every iteration of the forEach loop generates its own asynchronous operation, and beforeEach won't wait for them to finish executing
            the await commands defined inside of the forEach loop are not in the beforeEach function, but in separate functions that beforeEach will not wait for.
         One way of fixing this is to wait for all of the asynchronous operations to finish executing with the Promise.all method
            Promise.all executes the promises it receives in parallel
            If the promises need to be executed in a particular order, the operations can be executed inside of a for...of block
            The asynchronous nature of JavaScript can lead to surprising behavior
               pay careful attention when using the async/await syntax
               Even though the syntax makes it easier to deal with promises, it is still necessary to understand how promises work
      Refactoring tests
         This way of testing the API, by making HTTP requests and inspecting the database with Mongoose, is by no means the only nor the best way of conducting API-level integration tests
         There is no universal best way of writing tests, as it all depends on the application being tested and available resources.

c. User administration
      Users should be stored in the database and every note should be linked to the user who created i
      Deleting and editing a note should only be allowed for the user who created it.
      There is a one-to-many relationship between the user (User) and notes (Note). There are many different ways of modeling the situation.
      The existing solution saves every note in the notes collection in the database
      Like with all document databases, we can use object id's in Mongo to reference documents in other collections
         This is similar to using foreign keys in relational databases.
      read !
      document databases like Mongo do not support join queries that are available in relational databases
         However starting from version 3.2. Mongo has supported lookup aggregation queries
      In certain situations Mongoose can take care of joining and aggregating data, which gives the appearance of a join query
   References across collections
      If we were using a relational database the note would contain a reference key to the user who created it.
         In document databases we can do the same thing.
      read !
      The chosen schema must be one which supports the use cases of the application the best
   Mongoose schema for users
      In this case, we make the decision to store the ids of the notes created by the user in the user document
      read !
      In stark contrast to the conventions of relational databases, references are now stored in both documents
   Creating users
      Users have a unique username, a name and something called a passwordHash
      The password hash is the output of a one-way hash function applied to the user's password
      install the bcrypt package for generating the password hashes
         > npm install bcrypt
      read !
      practicing test-driven development (TDD), where tests for new functionality are written before the functionality is implemented.
      validate the uniqueness of the username with the help of Mongoose validators
         > npm install mongoose-unique-validator
   Creating a new note
      information about the user who created a note is sent in the userId field of the request body
      read and do !
   Populate
      when request is made to the /api/users route, the user objects would also contain the contents of the user's notes, and not just their id
         In a relational database, this functionality would be implemented with a join query.
      Mongoose accomplishes the join by doing multiple queries, which is different from join queries in relational databases which are transactional
          nothing can guarantee that the state between the collections being joined is consistent
      The Mongoose join is done with the populate method
      We can use the populate parameter for choosing the fields we want to include from the documents

d. Token authentication
      Install the jsonwebtoken library
         > npm install jsonwebtoken
      jwt only work in production env?
         > npm start
   Limiting creating new notes to logged in users
      change creating new notes so that it is only possible if the post request has a valid token attached
      use Bearer auth scheme
   Error handling
      The token can be faulty, falsified, or expired
      Github 4-9
   End notes
      Usernames, passwords and applications using token authentication must always be used over HTTPS
      the production version of our application is in Heroku, Heroku routes all traffic between a browser and the Heroku server over HTTPS

      