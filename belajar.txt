It is extremely unprofessional to leave any red output to the browser console.

> npx create-react-app part1
> cd part1
> npm start

belum bisa :
- End to end -testing Part 5.d

belu paham
- (event) parameter
- Promises, promise chaining

things I love :
- custom hooks

console warning :
https://stackoverflow.com/a/61442974/12250944

https://reactjs.org/docs/introducing-jsx.html

https://reactjs.org/docs/components-and-props.html

[ PART 1 ]
c. Component state, event handlers
   Complex state
      const [clicks, setClicks] = useState({
         left: 0, right: 0
      })
      const handleLeftClick = () =>
         setClicks({ ...clicks, left: clicks.left + 1 })
   Handling arrays state
      const [allClicks, setAll] = useState([])
      setAll(allClicks.concat('L'))
   Conditional rendering
   Old React
      we use the state hook to add state to our React components
      Before the addition of hooks, there was no way to add state to functional components
   Debugging React applications
      Keep the browser's developer console open at all times.
      add the React developer tools extension to add Components tab
   Rules of Hooks
      useState function and useEffect must not be called from inside of a loop, a conditional expression, or any place that is not a function defining a component
      hooks may only be called from the inside of a function body that defines a React component
   Event Handling Revisited
   Function that returns a function
      //state
      const [value, setValue] = useState(10)
      //the function
      const setToValue = (newValue) => () => {
         setValue(newValue)   }
      //event handler
      <button onClick={setToValue(0)}>reset</button>
   Passing Event Handlers to Child Components
      for example, by extracting the button into its own component
         <button onClick={props.handleClick}>   {props.text}   </button>
   Do Not Define Components Within Components
      The application still appears to work, but never define components inside of other components
	Useful Reading
   Excercise
      nice excercise
      most votes belum

[PART 2]
a. Rendering a collection, modules
   JavaScript Arrays
      functional programming methods of the JavaScript array, such as find, filter, and map
      https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84
      https://www.youtube.com/watch?v=-LFjnY1PEDA
   Rendering collections
      use map
   Key-attribute
      the elements generated by the map method, must each have a unique attribute called key
      <ul>
        {notes.map(note => 
          <li key={note.id}>  {note.content} </li>                  
        )}
      </ul>
   Map: map always creates a new array      
   Anti-pattern: don't use array indexes as keys 
   Refactoring modules
      Create a separate Note component, and define the key attribute for the Note components, and not for the li tags
      Common practice for building React app is to declare each component in their own file as an ES6-module
         add "export default Note" at the end of Note component file
         to import in index.js: import Note from './components/Note'
   When the application breaks
      Dynamically typed languages, such as JavaScript, where the compiler does not check the data type of, for instance, function variables or return values
      Use console.log for debugging
   Excercise

b. Forms
   expanding Note application by allowing users to add new notes
   Filtering Displayed Elements
      conditional operator
   Exercises: Phonebook
      template string

c. Getting data from server
         Create a file named db.json in the root directory of the project
         > npx json-server --port 3001 --watch db.json
      The browser as a runtime environment
         In Java the code executes line by line and stops to wait for the HTTP request
         JavaScript engines, or runtime environments, follow the asynchronous model
            this requires all IO-operations (with some exceptions) to be executed as non-blocking
            the code execution continues immediately after calling an IO function, without waiting for it to return
            When an asynchronous operation is completed, the JavaScript engine calls the event handlers registered to the operation
            Currently, JavaScript engines are single-threaded, which means that they cannot execute code in parallel
               As a result, it is a requirement in practice to use a non-blocking model for executing IO operations
               Otherwise, the browser would "freeze" during, for instance, the fetching of data from a server.
               Another consequence of this single-threaded nature of JavaScript engines is that if some code execution takes up a lot of time, the browser will get stuck for the duration of the execution
      npm
         JavaScript projects are defined using the node package manager, aka npm
         > npm install axios
         npm-commands should always be run in the project root directory,where the package.json file can be found
         > npm install json-server --save-dev
            adding "server" to package.json
            > npm run server
            To run json-server and your react app simultaneously, you may need to use two terminal windows. One to keep json-server running and the other to run react-app.
      Axios and promises
         A Promise is an object representing the eventual completion or failure of an asynchronous operation.
         A promise can have three distinct states: pending, fulfiled, rejected
         const promise = axios.get('http://localhost:3001/notes')
            to access the result of the operation represented by the promise, we must register an event handler to the promise
            axios.get('http://localhost:3001/notes').then(response => {
               const notes = response.data
               console.log(notes)   })
      Effect-hooks
         The Effect Hook lets you perform side effects in function components.
         Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.
         penjelasan proses fetching data dari server
            Understanding the order of events is critical!
      The development runtime environment
      Exercise skip dulu
d. Altering data in server
   REST
   Sending Data to the Server
   Changing the importance of notes
   Extracting communication with the backend into a separate module
      single responsibility principle
      create a src/services directory and add a file there called notes.js
      Promises are central to modern JavaScript development
   Cleaner syntax for defining object literals
   Promises and errors
      common way of adding a handler for rejected promises is to use the catch method
      When our application makes an HTTP request, we are in fact creating a promise chain:
      The catch method can be used to define a handler function at the end of a promise chain
e. Adding styles to React app
   CSS
   Improved error message
   Inline styles
      Any React component or element can be provided with a set of CSS properties as a JavaScript object through the style attribute
      CSS rules are defined slightly differently in JavaScript than in normal CSS files
      CSS properties are written in camelCase
      Inline styles and some of the other ways of adding styles to React components go completely against the grain of old conventions
         Traditionally, it has been considered the best practice to entirely separate CSS from the content (HTML) and functionality (JavaScript)
         The philosophy of React is, in fact, the polar opposite of this.
         Since the separation of CSS, HTML, and JavaScript into separate files did not seem to scale well in larger applications
            React bases the division of the application along the lines of its logical functional entities
               The structural units that make up the application's functional entities are React components
               A React component defines the HTML for structuring the content
               the JavaScript functions for determining functionality, and also the component's styling; all in one place
               This is to create individual components that are as independent and reusable as possible.

[PART 3]
a. Node.js and Express
      We will be building our backend on top of NodeJS, which is a JavaScript runtime based on Google's Chrome V8 JavaScript engine
      > npm init
         automatically generated package.json file at the root of the project, that contains information about the project.
   Simple web server
   Express
      Many libraries have been developed to ease server side development with Node
      These libraries aim to provide a better abstraction for general use cases we usually require to build a backend server
      By far the most popular library intended for this purpose is express.
      > npm install express
      The versioning model used in npm is called semantic versioning.
      We can update the dependencies of the project with the command:
         > npm update
      Likewise, if we start working on the project on another computer, we can install all up-to-date dependencies of the project defined in package.json with a command :
         > npm install
   Web and express
      With express, transformation to JSON format happens automatically
      JSON is a string, and not a JavaScript object like the value assigned to notes
   nodemon
      If we make changes to the application's code we have to restart the application in order to see the changes, unlike the convenient workflow in React
         The solution to this problem is nodemon
      nodemon will watch the files in the directory in which nodemon was started, and if any files change, nodemon will automatically restart your node application.
      Let's install nodemon by defining it as a development dependency with the command:
         > npm install --save-dev nodemon
      By development dependencies, we are referring to tools that are needed only during the development of the application, e.g. for testing or automatically restarting the application
      These development dependencies are not needed when the application is run in production mode on the production server (e.g. Heroku).
         change script and run 
            > npm run dev
      even though the backend server restarts automatically, the browser still has to be manually refreshed
   REST
      REST is an architectural style meant for building scalable web applications.
   Fetching a single resource
      In JavaScript, the "triple equals" comparison === considers all values of different types to not be equal by default, meaning that 1 is not '1'.
         changing the id parameter found in request.params.id from a string into a number:
            const id = Number(request.params.id)
      If no note is found, the server should respond with the status code 404 not found instead of 200
   Deleting resources
      Deletion happens by making an HTTP DELETE request to the url of the resource
      If deleting the resource is successful, we respond to the request with the status code 204 no content
   Postman
      Many tools exist for making the testing of backends easier. One of these is a command line program curl
      However, instead of curl, we will take a look at using Postman for testing the application.
   The Visual Studio Code REST client
      you can use the VS Code REST client plugin instead of Postman.
      We save all the REST client requests in the directory as files that end with the .rest extension
   Receiving data
      Adding a note happens by making an HTTP POST request
      In order to access the data easily, we need the help of the express json-parser
         that is taken to use with command app.use(express.json()).
         Without the json-parser, the body property would be undefined
         The json-parser takes the JSON data of a request, transforms it into a JS object and attaches it to the body property of the request object
      Dont forget to change Content-type
      it is better to generate timestamps on the server than in the browser 
   About HTTP request types
      The HTTP standard talks about two properties related to request types, safety and idempotence.
      Safe : GET and HEAD
         Safety means that the executing request must not cause any side effects in the server
      Idempotent : GET, HEAD, PUT and DELETE share this property ?
   Middleware
      The express json-parser we took into use earlier is a so-called middleware.
      Middleware are functions that can be used for handling request and response objects.
      Middleware is a function that receives three parameters:
      we can use several middleware at the same time
      Middleware functions are called in the order that they're taken into use with the express server object's use method
      Middleware can be called before and after routes
         unknownEndpoint called after routes, if unknown endpoint was given by client
      http://expressjs.com/en/guide/using-middleware.html

b. Deploying app to internet     
   Same origin policy and CORS
      Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources (e.g. fonts) on a web page to be requested from another domain
      by default, the JavaScript code of an application that runs in a browser can only communicate with a server in the same origin.
         Because our server is in localhost port 3001, and our frontend in localhost port 3000, they do not have the same origin.
      same origin policy and CORS are not specific to React or Node
      We can allow requests from other origins by using Node's cors middleware.
         > npm install cors
      take the middleware to use and allow for requests from all origins:
   Application to the Internet
      let's move our application to the internet using Heroku
      install heroku, login first. Then follow instruction
      push issue : https://stackoverflow.com/a/34573866/12250944
      https://stark-ravine-43458.herokuapp.com/api/notes
   Frontend production build
      So far we have been running React code in development mode         
         In development mode the application is configured to give clear error messages, immediately render code changes to the browser, and so on.
      When the application is deployed, we must create a production build or a version of the application which is optimized for production.
         > npm run build
         This creates a directory called build (which contains the only HTML file of our application, index.html ) which contains the directory static
         Minified version of our application's JavaScript code will be generated to the static directory
         Even though the application code is in multiple files, all of the JavaScript will be minified into one file
      Serving static files from the backend
         One option for deploying the frontend is to copy the production build (the build directory) to the root of the backend repository ...
         if both the frontend and the backend are at the same address, we can declare baseUrl as a relative URL
         copy build in frontend to backend. commit and push backend to heroku
         https://stark-ravine-43458.herokuapp.com/
         Our application saves the notes to a variable. If the application crashes or is restarted, all of the data will disappear. It needs a database
      Streamlining deploying of the frontend
         add some npm-scripts to the package.json of the backend repository
      Proxy
         ?
c. Saving data to MongoDB
   Debugging Node applications
      Printing to the console is always worth doing
      The Visual Studio Code debugger can be useful in some situations.
         Click Run -> start debugging on VS Code
      Chrome dev tools
         Debugging is also possible with the Chrome developer console by starting your application with the command:
            node --inspect index.js
      Question everything
         there will be many potential areas for bugs in the application.
         When the application "does not work", we have to first figure out where the problem actually occurs
         The key is to be systematic. Since the problem can exist anywhere, you must question everything, and eliminate all possibilities one by one
            Logging to the console, Postman, debuggers, and experience will help.
         When bugs occur, the worst of all possible strategies is to continue writing code
            It will guarantee that your code will soon have even more bugs, and debugging them will be even more difficult.
   MongoDB
      In this course we will use MongoDB which is a so-called document database.
      Document databases differ from relational databases in how they organize data as well as the query languages they support.
      Document databases are usually categorized under the NoSQL umbrella term.
      MongoDB Atlas: database service for MongoDB
         create organization and create project on mangodb web first
         create a starter cluster for free
         add user for database access
            username : notesapp, pass : passdbnotesapp
         follow instruction ...
      use Mongoose as an object document mapper (ODM), and saving JavaScript objects as Mongo documents
         > node mongo.js passdbnotesapp
   Schema
      After establishing the connection to the database, we define the schema for a note and the matching model:
   Creating and saving objects
   Fetching objects from the database
      The objects are retrieved from the database with the find method of the Note mode
   Backend connected to a database
   Database configuration into its own module
      create a new directory for the module called models, and add a file called note.js
      There are many ways to define the value of an environment variable
      It's not a good idea to hardcode the address of the database into the code
         so instead the address of the database is passed to the application via the MONGODB_URI environment variable.
         There are many ways to define the value of an environment variable
            A more sophisticated way is to use the dotenv library
            > npm install dotenv
   Using database in route handlers
      Creating a new note and save it to db
      use Mongoose's findById method to fetch an individual note 
   Verifying frontend and backend integration
      get and post note work fine
   Error handling
      When dealing with Promises, it's almost always a good idea to add error and exception handling, 
         because otherwise you will find yourself dealing with strange bugs
   Moving error handling into middleware
      But there are cases where it is better to implement all error handling in a single place
         This can be useful if we later on want to report data related to errors to an external error tracking system like Sentry
   The order of middleware loading
      The execution order of middleware is the same as the order that they are loaded into express with the app.use function.
      The json-parser middleware should be among the very first middleware loaded into Express
      middleware for handling unsupported routes is next to the last middleware that is loaded into Express, just before the error handler
   Other operations
      add deleting and updating an individual note functionality 
      The easiest way to delete a note from the database is with the findByIdAndRemove method
      update uses findByIdAndUpdate method
         By default, the updatedNote parameter of the event handler receives the original document
         We added the optional { new: true }parameter, which will cause our event handler to be called with the new modified document instead of the original.

d. Validation and ESLint
         There are usually constraints that we want to apply to the data that is stored in our application's database. 
         One way of validating the format of the data is to use the validation functionality available in Mongoose.
         COBA VALIDATION, BELUM BERHASIL
      Promise chaining
         Promise chaining provides much benefit if there were many asynchronous operations that had to be done in sequence using async/await syntax in JavaScript
      Deploying the database backend to production
         heroku config:set doesn't work
         https://stackoverflow.com/questions/55876225/cant-connect-to-mongodb-using-environment-variable-for-heroku
      Lint
         lint or a linter is any tool that detects and flags errors in programming languages, including stylistic errors
         Lint-like tools generally perform static analysis of source code.
         Let's install ESlint as a development dependency to the backend project 
            > npm install eslint --save-dev
            > npx eslint --init
            The configuration will be saved in the .eslintrc.js file
         https://eslint.org/docs/rules/
         Many companies define coding standards that are enforced throughout the organization through the ESlint configuration file.
         it can be a good idea to adopt a ready-made configuration from someone else's project into yours.
         Recently many projects have adopted the Airbnb Javascript style guide by taking Airbnb's ESlint configuration into use

[PART 4]
a. Structure of backend application, introduction to testing
      Project structure
         modify the structure of our project to adhere to Node.js best practices.
         separate all printing to the console to its own module utils/logger.js
         The index.js file only imports the actual application from the app.js file and then starts the application.
         The handling of environment variables is extracted into a separate utils/config.js file
         The route handlers have also been moved into a dedicated module (controllers).
            All of the routes related to notes are now in the notes.js module under the controllers directory.
         A router object is an isolated instance of middleware and routes.
         The app.js file that creates the actual application, takes different middleware into use
         custom middleware has been moved to a new utils/middleware.js module
         The responsibility of establishing the connection to the database has been given to the app.js
         The note.js file under the models directory only defines the Mongoose schema for notes
         Once the application starts to grow in size, you are going to have to establish some kind of structure
            and separate the different responsibilities of the application into separate modules
      Testing Node applications
         one essential area of software development is automated testing
         we will be using a testing library developed and used internally by Facebook called jest
         Jest is a natural choice for this course, as it works well for testing backends, and it shines when it comes to testing React applications.
         install jest as a development dependency
            > npm install --save-dev jest
         Individual test cases are defined with the test function
         run the test using command:
            > npm test
            Jest expects by default that the names of test files contain .test
         Describe blocks can be used for grouping tests into logical collections

b. Testing the backend
         Since the backend does not contain any complicated logic, it doesn't make sense to write unit tests for it
         The only potential thing we could unit test is the toJSON method that is used for formatting notes.
         it can be beneficial to implement some of the backend tests by mocking the database instead of using a real database
            One library that could be used for this is mongo-mock.
         Since our application's backend is simple, we willtest the entire application through its REST API, so that the database is also included
            This kind of testing where multiple components of the system are being tested as a group, is called integration testing.
      Test environment
         when your backend server is running in Heroku, it is in production mode.
         > npm install --save-dev cross-env
         We can create our separate test database in Mongo DB Atlas.
            This is not an optimal solution in situations where there are many people developing the same application. 
            It would be better to run our tests using a database that is installed and running in the developer's local machine. 
            This is "relatively simple" to achieve by running Mongo in-memory or by using Docker containers.
            We will not complicate things and will instead continue to use the MongoDB Atlas database.
         We specified the mode of the application to be development in the npm run dev script that uses nodemon.
         We also specified that the default npm start command will define the mode as production.
      supertest
         use the supertest package to help us write our tests for testing the API.
         async/await syntax is related to the fact that making a request to the API is an asynchronous operation
      Initializing the database before tests
         In order to make our tests more robust, we have to reset the database and generate the needed test data in a controlled manner before we run the tests
         Our tests are already using the afterAll function of Jest to close the connection to the database after the tests are finished executing
         initialize the database before every test with the beforeEach function
      Running tests one by one
         > npm test -- tests/note_api.test.js
         > npm test -- -t 'a specific note is within the returned notes'
      async/await
         async/await syntax makes it possible to use asynchronous functions that return a promise in a way that makes the code look synchronous
         read explanation in course
         In order to use the await operator with asynchronous operations, they have to return a promise
         The await keyword can't be used just anywhere in JavaScript code.
            Using await is possible only inside of an async function.
      async/await in the backend
         change the route handler functions into async functions.
      More tests and refactoring the backend
         When code gets refactored, there is a risk of regression, meaning that existing functionality may break
         The code using promises works and the tests pass. We are ready to refactor our code to use the async/await syntax.
      Error handling and async/await
         With async/await the recommended way of dealing with exceptions is the old and familiar try/catch mechanism
         The catch block simply calls the next function, which passes the request handling to the error handling middleware.
      Eliminating the try-catch
         The express-async-errors library has a solution for refactoring the code to eliminate the catch from the methods
            > npm install express-async-errors
            the library allows us to eliminate the try-catch blocks completely
            Because of the library, we do not need the next(exception) call anymore
            If an exception occurs in a async route, the execution is automatically passed to the error handling middleware.
      Optimizing the beforeEach function
         a better way of saving multiple objects to the database
         every iteration of the forEach loop generates its own asynchronous operation, and beforeEach won't wait for them to finish executing
            the await commands defined inside of the forEach loop are not in the beforeEach function, but in separate functions that beforeEach will not wait for.
         One way of fixing this is to wait for all of the asynchronous operations to finish executing with the Promise.all method
            Promise.all executes the promises it receives in parallel
            If the promises need to be executed in a particular order, the operations can be executed inside of a for...of block
            The asynchronous nature of JavaScript can lead to surprising behavior
               pay careful attention when using the async/await syntax
               Even though the syntax makes it easier to deal with promises, it is still necessary to understand how promises work
      Refactoring tests
         This way of testing the API, by making HTTP requests and inspecting the database with Mongoose, is by no means the only nor the best way of conducting API-level integration tests
         There is no universal best way of writing tests, as it all depends on the application being tested and available resources.

c. User administration
      Users should be stored in the database and every note should be linked to the user who created i
      Deleting and editing a note should only be allowed for the user who created it.
      There is a one-to-many relationship between the user (User) and notes (Note). There are many different ways of modeling the situation.
      The existing solution saves every note in the notes collection in the database
      Like with all document databases, we can use object id's in Mongo to reference documents in other collections
         This is similar to using foreign keys in relational databases.
      read !
      document databases like Mongo do not support join queries that are available in relational databases
         However starting from version 3.2. Mongo has supported lookup aggregation queries
      In certain situations Mongoose can take care of joining and aggregating data, which gives the appearance of a join query
   References across collections
      If we were using a relational database the note would contain a reference key to the user who created it.
         In document databases we can do the same thing.
      read !
      The chosen schema must be one which supports the use cases of the application the best
   Mongoose schema for users
      In this case, we make the decision to store the ids of the notes created by the user in the user document
      read !
      In stark contrast to the conventions of relational databases, references are now stored in both documents
   Creating users
      Users have a unique username, a name and something called a passwordHash
      The password hash is the output of a one-way hash function applied to the user's password
      install the bcrypt package for generating the password hashes
         > npm install bcrypt
      read !
      practicing test-driven development (TDD), where tests for new functionality are written before the functionality is implemented.
      validate the uniqueness of the username with the help of Mongoose validators
         > npm install mongoose-unique-validator
   Creating a new note
      information about the user who created a note is sent in the userId field of the request body
      read and do !
   Populate
      when request is made to the /api/users route, the user objects would also contain the contents of the user's notes, and not just their id
         In a relational database, this functionality would be implemented with a join query.
      Mongoose accomplishes the join by doing multiple queries, which is different from join queries in relational databases which are transactional
          nothing can guarantee that the state between the collections being joined is consistent
      The Mongoose join is done with the populate method
      We can use the populate parameter for choosing the fields we want to include from the documents

d. Token authentication
      Install the jsonwebtoken library
         > npm install jsonwebtoken
      jwt only work in production env?
         > npm start
   Limiting creating new notes to logged in users
      change creating new notes so that it is only possible if the post request has a valid token attached
      use Bearer auth scheme
   Error handling
      The token can be faulty, falsified, or expired
      Github 4-9
   End notes
      Usernames, passwords and applications using token authentication must always be used over HTTPS
      the production version of our application is in Heroku, Heroku routes all traffic between a browser and the Heroku server over HTTPS

[PART 5]

a. Login in frontend
      modify app component
      The app state has fields for username and password to store the data from the form
      The form fields have event handlers, which synchronize changes in the field to the state of the App component
      The event handlers: An object is given to them as a parameter, and they destructure the field target from the object and save its value to the state
      Github 5-1
      Use async/await syntax instead of promises for the login request
      show the login form only if the user is not logged-in
   Creating new notes
      adding new notes with user token works
   Saving the token to the browser's local storage
      Our application has a flaw: when the page is rerendered, information of the user's login disappears
      Local Storage is a key-value database in the browser.
      A value corresponding to a certain key is saved to the database with method setItem
         window.localStorage.setItem('name', 'juha tauriainen')
      The value of a key can be found with method getItem:
         window.localStorage.getItem('name')
      and removeItem removes a key.
      Values saved to the storage are DOMstrings, so we cannot save a JavaScript object as is
         The object has to be parsed to JSON first, with the method JSON.stringify
         when a JSON object is read from the local storage, it has to be parsed back to JavaScript with JSON.parse
         On Chrome, go to the Application tab and select Local Storage 
      We still have to modify our application so that when we enter the page, the application checks if user details of a logged-in user can be found on the local storage
         The right way to do this is with an effect hook: a mechanism we first encountered in part 2
         The empty array as the parameter of the effect ensures that the effect is executed only when the component is rendered for the first time.
      Now a user stays logged-in in the application forever
         (exercise) add a logout functionality which removes the login details from the local storage

b. props.children and proptypes
   Displaying the login form only when appropriate
      modify the application so that login form appears when the user presses the login button
      start by extracting the login form into its own component (LoginForm,js)
      set button visibility by giving the component an inline CSS style rule
   The components children, aka. props.children
      Extracting the code related to managing the visibility of the login form to a new Togglable component
         LoginForm is a child component of Togglable component
      props.children, is used for referencing the child components of the component
         Unlike the "normal" props we've seen before, children is automatically added by React and always exists
   State of the forms
      https://reactjs.org/docs/lifting-state-up.html
         We could move the state of the forms to the corresponding components.
      read !
   References to components with ref
      Refs provide a way to access DOM nodes or React elements created in the render method.
      the useImperativeHandle function is a React hook, that is used for defining functions in a component which can be invoked from outside of the component
      There are also other use cases for refs than accessing React components
   One point about components
      When we define a component in React, and use it multiple time 
         We create three separate instances of the component that all have their own separate state
   Exercises 5.5.-5.10 skip
   PropTypes
      We can define a component prop as a mandatory or required string-type prop using library
      The expected and required props of a component can be defined with the prop-types package
         > npm install prop-types
      The console will display error message if the prop is left undefined
      Let's also define PropTypes to the LoginForm component
         If the type of a passed prop is wrong, e.g. if we try to define the handleSubmit prop as a string, then the console will display warning
   ESlint
      Create-react-app has installed ESlint to the project by default, we have to define our desired configuration in the .eslintrc.js file
      we will start testing the frontend and in order to avoid undesired and irrelevant linter errors we will install the eslint-plugin-jest package
         > npm install --save-dev eslint-plugin-jest
      create a .eslintrc.js file
      create .eslintignore file and skip build and node_modules directory
      create a npm script to run the lint
      (penting) run npm run lint -- --fix to get rid of current CRLF
      https://stackoverflow.com/a/63512242/12250944
         remove "error 'module' is not defined no-undef"

c. Testing React apps
      Tests will be implemented with testing library developed by Facebook
      Jest is actually configured by default to applications created with create-react-app
      In addition to Jest, we also need another testing library that will help us render components for testing purposes
         The current best option for this is react-testing-library
            > npm install --save-dev @testing-library/react 
            > npm install --save-dev @testing-library/jest-dom
      write tests for the component that is responsible for rendering a note
         the li element has the CSS classname note, that is used to access the component in our tests
   Rendering the component for tests
      write our test in the src/components/Note.test.js file, which is in the same directory as the component itself
      render returns an object that has several properties. One of the properties is called container, and it contains all of the HTML rendered by the component
   Running tests
      Create-react-app configures tests to be run in watch mode by default
      npm test command will not exit once the tests have finished, and will instead wait for changes to be made to the code
      Once new changes to the code are saved, the tests are executed automatically
      (BELUM BISA) use Watchman to run test normally
         (doesn't work) https://stackoverflow.com/questions/38451764/how-to-install-watchman-on-windows-win10
         https://www.youtube.com/watch?v=1ap3hL-UR9I
   Test file location
      In React there are (at least) two different conventions for the test file's location
         - placing them in the same directory as the component being tested
         - store the test files "normally" in their own separate directory
   Searching for content in a component
      The react-testing-library package offers many different ways of investigating the content of the component being tested
         - uses method toHaveTextContent to search for a matching text from the entire HTML code rendered by the component
         - uses the getByText method of the object returned by the render method
         - search for a specific element that is rendered by the component with the querySelector method
   Debugging tests
      The object returned by the render method has a debug method that can be used to print the HTML rendered by the component to the console
      It is also possible to search for a smaller part of the component and print its HTML code
         we need the prettyDOM method that can be imported from the @testing-library/dom package that is automatically installed with react-testing-library
   Clicking buttons in tests
      the Note component also makes sure that when the button associated with the note is pressed, the toggleImportance event handler function gets called.
      Clicking happens with the fireEvent method.
   Tests for the Togglable component
      add the togglableContent CSS classname to the div that returns the child components
   Testing the forms
      beforeEach function gets called before each test, which then renders the Togglable component into the component variable
   Testing the forms
      Other than create a click event for the button component, We can also simulate text input with fireEvent
      The form works by calling the createNote function it received as props with the details of the new note.
   Test coverage
      > npm test -- --coverage
   Frontend integration tests
      read
   Snapshot testing
      read

d. (sulit, belum berhasil) End to end -testing
      We will look into one way to test the system as a whole using End to End (E2E) tests
      We can do E2E testing of a web application using a browser and a testing library, for example Selenium 
      E2E tests are potentially the most useful category of tests, because they test the system through the same interface as real users use
      They do have some drawbacks too. Configuring E2E tests is more challenging than unit or integration tests
   Cypress
      E2E library Cypress has become popular within the last year. 
      Cypress is exceptionally easy to use, and when compared to Selenium, it requires a lot less hassle and headache
      installing Cypress to the frontend as development dependency
         > npm install --save-dev cypress
      Cypress tests can be in the frontend or the backend repository, or even in their own separate repository.
      The tests require the tested system to be running. Cypress tests do not start the system when they are run
      praktik !
   Writing to a form
      extend our tests so, that the test tries to log in to our application
      It would be better to give our inputs unique ids and use those to find them
   Some things to note
      the variable cy our tests use gives us a nasty Eslint error
      get rid of it by installing eslint-plugin-cypress as a development dependency
         > npm install eslint-plugin-cypress --save-dev
   Testing new note form
      Only logged in users can create new notes, so we added logging in to the application to a beforeEach block
      Cypress runs the tests in the order they are in the code
   Controlling the state of the database
      If the tests need to be able to modify the server's database, the server's database should be the same each time we run the tests, so our tests can be reliably and easily repeatable
      As with unit and integration tests, with E2E tests it is the best to empty the database and possibly format it before the tests are run
      The challenge with E2E tests is that they do not have access to the database.
         The solution is to create API endpoints to the backend for the test (controllers/testing.js)
      add a new user to the backend from the beforeEach block.
      During the formatting the test does HTTP requests to the backend with cy.request.
         now the testing starts with the backend in the same state every time. The backend will contain one user and no notes.
   Failed login test
      make a test to ensure that a login attempt fails if the password is wrong.
      hen developing a new test or when debugging a broken test, we can define the test with it.only instead of it
   Bypassing the UI
      Under the hood cy.request, like all Cypress commands, are promises
      If and when we write new tests to our application, we have to use the login code in multiple places. We should make it a custom command.
         Custom commands are declared in cypress/support/commands.js

PART 6
a. Flux-architecture and Redux
      So far, we have placed the application's state and state logic directly inside React-components.
      When applications grow larger, state management should be moved outside React-components
      Redux-library is the most popular solution for managing the state of React-applications
   Flux-architecture
      Facebook developed the Flux- architecture to make state management easier
      read !
   Redux
      Redux works with the same principle as Flux, but is a bit simpler. Facebook also uses Redux now instead of their original Flux.
      install redux with the command
         > npm install redux
      As in Flux, in Redux the state is also stored in a store. The state of the store is changed with actions
      Actions are objects, which have at least a field determining the type of the action
      The impact of the action to the state of the application is defined using a reducer
         reducer is a function which is given the current state and an action as parameters. It returns a new state.
      Reducer is never supposed to be called directly from the applications code
         Reducer is only given as a parameter to the createStore-function which creates the store
      The store uses the reducer to handle actions, which are dispatched or 'sent' to the store with its dispatch-method.
      You can find out the state of the store using the method getState
      subscribe method is used to create callback functions the store calls when its state is changed.
   Redux-notes
      cover a few key concepts through a simplified note application
   Pure functions, immutable
      Redux reducer that reducers must be pure functions
      Pure functions do not cause any side effects and they must always return the same response when called with the same parameters
      A reducer state must be composed of immutable objects
         If there is a change in the state, the old object is not changed, but it is replaced with a new, changed, object
         use concat method, which creates a new array
      Expand the reducer in the 'test driven' way. Create a test for handling the action NEW_NOTE
      add the library deep-freeze, which can be used to ensure that the reducer has been correctly defined as an immutable function
         > npm install --save-dev deep-freeze
         The deepFreeze(state) command ensures that the reducer does not change the state of the store given to it as a parameter
            If the reducer uses the push command to manipulate the state, the test will not pass
   Array spread syntax
      Adding a new note create by using the JavaScript array spread -syntax
   Uncontrolled form
      add the functionality for adding new notes and changing their importance
      we have not bound the state of the form fields to the state of the App component like we have previously done
         React calls this kind of form uncontrolled
         Uncontrolled forms have certain limitations (for example, dynamic error messages or disabling the submit button based on input are not possible)
      We can get the content of the new note straight from the form field. we can access the content via the event object event.target.note.value
   Action creators
      It is not necessary for React-components to know the Redux action types and forms
         Let's separate creating actions into their own functions. Functions that create actions are called action creators
   Forwarding Redux-Store to various components
      when a component is composed of many smaller components, there must be a way for all of the components to access the store.
      Use react-redux library to share the redux-store with components
         > npm install react-redux
      the application is now defined as a child of a Provider -component provided by the react redux library
         The application's store is given to the Provider as its attribute store
      If the application has many components which need the store, the App-component must pass store as props to all of those components.
      A module can have only one default export, but multiple "normal" exports
         Normally (not as defaults) exported functions can be imported with the curly brace syntax
      Previously the code dispatched actions by calling the dispatch method of the redux-store
         Now it does it with the dispatch-function from the useDispatch -hoo
         useDispatch-hook provides any React component access to the dispatch-function of the redux-store defined in index.js
            This allows all components to make changes to the state of the redux-store.
      The component can access the notes stored in the store with the useSelector-hook of the react-redux library.
   More components
      separate creating a new note into its own component
      the event handler for changing the state of the app (which now lives in Redux) has been moved away from the App to a child componen
      separate the list of notes and displaying a single note into their own components
         The logic for changing the importance of a note is now in the component managing the list of notes.
         Note, responsible for rendering a single note, is not aware that the event handler it gets as props dispatches an action. These kind of components are called presentational
         Notes, is a container component, as it contains some application logic:
            - it defines what the event handlers of the Note components do
            - coordinates the configuration of presentational components, that is, the Note
   Github, branch part 6-1

b. Many reducers
      change our reducer so that the store gets initialized with a state that contains a couple of notes
   Store with complex state
      implement filtering for the notes that are displayed to the user using radio buttons
      the new implementation of state object has two properties, notes that contains the array of notes and filter that contains a string indicating which notes should be displayed
   Combined reducers
      define a new separate reducer for the state of the filter
      create the actual reducer for our application by combining the two existing reducers with the combineReducers function
         The state of the store defined by the reducer is an object with two properties: notes (noteReducer) and filter (filterReducer)
      The combined reducer works in such a way that every action gets handled in every part of the combined reducer
   Finishing the filters
      extract the visibility filter into its own VisibilityFilter.js component
   Redux DevTools
      Chrome extension Redux DevTools can be installed to monitor state of the Redux-store and the action that changes it from the console of the browser
      When debugging, in addition to the browser extension we also have the software library redux-devtools-extension
         > npm install --save-dev redux-devtools-extension

c. Communicating with server in a redux application
      expand the application, such that the notes are stored to the backend.Use json-server, familiar from part 2.
      The initial state of the database is stored into the file db.json
      install json-server for the project
         > npm install json-server --save-dev
      modify scripts part of the file package.json and run > npm run server
      add axios to the project > npm install axios
      change the initialization of the state in noteReducer, such that by default there are no notes
   Do !!
   Asynchronous actions and redux thunk
      Our approach is OK, but it is not great that the communication with the server happens inside the functions of the components
         the communication could be abstracted away from the components, so they don't have to do anything else but call the appropriate action creator
      DO !!
      install the redux-thunk-library, which enables us to create asynchronous actions
         > npm install redux-thunk
         redux-thunk-library is a so-called redux-middleware, which must be initialized along with the initialization of the store
      extract the definition of the store into its own file src/store.js:
      do !!

d. connect
      we have used our redux-store with the help of the hook-api from react-redux
         Practically this has meant using the useSelector and useDispatch functions
      In new applications you should absolutely use the hook-api, but knowing how to use connect is useful when maintaining older projects using redux.
   Using the connect-function to share the redux store to components
      modify the Notes component so that instead of using the hook-api (the useDispatch and useSelector functions ) it uses the connect-function
      Connect function can be used for transforming "regular" React components so that the state of the Redux store can be "mapped" into the component's props
      The connect function accepts mapStateToProps function for defining the props of the connected component that are based on the state of the Redux store.
   mapDispatchToProps
      The second parameter of the connect function can be used for defining mapDispatchToProps
         which is a group of action creator functions passed to the connected component as props
      Let's also use connect to create new notes
         Since the component does not need to access the store's state, we can simply pass null as the first parameter to connect.
   Referencing action creators passed as props
      read!!
   Alternative way of using mapDispatchToProps
      The functions passed in mapDispatchToProps must be action creators, that is, functions that return Redux actions.
      In this alternative definition, mapDispatchToProps is a function that connect will invoke by passing it the dispatch-function as its paramete
   The creator of Redux has created a wonderful tutorial called Getting started with Redux that you can find on Egghead.io.
   Presentational/Container revisited
      read !!
   Redux and the component state
      React only focuses on generating the views, and the application state is separated completely from the React components and passed on to Redux, its actions, and its reducers.
      What about the useState-hook, which provides components with their own state?
         If the application has more complicated forms, it may be beneficial to implement their local state using the state provided by the useState function
      Should we always use redux? Probably not. Dan Abramov, the developer of redux, discusses this in his article You Might Not Need Redux.
      Nowadays it is possible to implement redux-like state management without redux by using the React context-api and the useReducer-hook

[PART 7]
      React router helps us divide the application into different views that are shown based on the URL in the browser's address ba
      we'll look at a few more ways to add CSS-styles to React applications
      we'll learn how Webpack works and how we can use it to configure the application ourselves
      have a look on hook-functions and how to define a custom hook.
a. React-router
   Application navigation structure
      It is very common for web-applications to have a navigation bar, which enables switching the view of the application.
      In an old school web app, changing the page is accomplished by the browser making an HTTP GET request to the server and rendering the HTML representing the view that was returned
      In SPA, we are, in reality, always on the same page. The Javascript code run by the browser creates an illusion of different "pages"
      If HTTP requests are made when switching view, they are only for fetching JSON formatted data, which the new view might require for it to be shown
      Each view is implemented as its own component. We store the view component information in the application state called page
         This information tells us which component, representing a view, should be shown below the menu bar.
      The method is not very optimal, because the address stays the same even though at times we are in different views and the back-button doesn't work as expected
         React has the React router-library, which provides an excellent solution for managing navigation
            > npm install react-router-dom
      Routing, or the conditional rendering of components based on the url in the browser, is used by placing components as children of the Router component, meaning inside Router-tags
      even though the component is referred to by the name Router, we are in fact talking about BrowserRouter
         BrowserRouter is a Router that uses the HTML5 history API (pushState, replaceState and the popState event) to keep your UI in sync with the URL
         with the help of the HTML5 history API BrowserRouter enables us to use the URL in the address bar of the browser for internal "routing" in a React-application
         So, even if the URL in the address bar changes, the content of the page is only manipulated using Javascript, and the browser will not load new content form the server
         Using the back and forward actions, as well as making bookmarks, is still logical like on a traditional web page.
      Inside the router we define links that modify the address bar with the help of the Link component
      Components rendered based on the URL of the browser are defined with the help of the component Route
      We wrap the components to be rendered based on the url with a Switch-component
         Note that the order of the components is important
         If we put the Home-component, whose path is path="/", first, nothing else would ever get rendered because the "nonexistent" path "/" is the start of every path
   Parameterized route
      The application now contains five different views whose display is controlled by the router
      In addition to Home, Notes and Users, we have Login representing the login view and Note representing the view of a single note
         Notes renders the list of notes passed to it as props in such a way that the name of each note is clickable
         The ability to click a name is implemented with the component Link
         define the route rendering a specific note "express style" by marking the parameter with a colon :id
         When a browser navigates to the url for a specific note, for example /notes/3, we render the Note component
         Note component receives all of the notes as props notes, and it can access the url parameter (the id of the note to be displayed) with the useParams function of the react-router
   useHistory
      If a user is logged in, information about a logged in user is saved to the user field of the state of the App component
      The option to navigate to the Login-view is rendered conditionally in the menu
      use useHistory function of the react-router in Login component to access a history object
         The history object can be used to modify the browser's url programmatically.
         With user log in, the history.push('/') call causes the browser's url to change to / and the application renders the corresponding component Home.
      Both useParams and useHistory are hook-functions, just like useState and useEffect
         Create-react-app has been configured to warn you if you break hook-functions rules
   redirect
      If a user isn't logged in, the Users component is not rendered. Instead, the user is redirected using the Redirect-component to the login view
      it would perhaps be better to not even show links in the navigation bar requiring login if the user is not logged into the application
      define an element called footer, which defines the part at the bottom of the screen, outside of the Router, so that it is shown regardless of the component shown
   Parameterized route revisited
      Our application has a flaw. The Note component receives all of the notes, even though it only displays the one whose id matches the url parameter
      use react-router's useRouteMatch hook to figure out the id of the note to be displayed in the App component
         move the use of the Router components from App to use useRouteMatch-hook
      Every time the component is rendered, or every time the browser's url changes, useRouteMatch('/notes/:id') is executed

b. Custom hooks
   Hooks
      React offers 10 different built-in hooks, popular ones are the useState and useEffect hooks
      In part 5 we used the useImperativeHandle-hook which allows for components to provide their functions to other components.
      we used the useSelector and useDispatch hooks from the react-redux library to share our redux-store and dispatch function to our components
      React-router's api is also partially hook based. Its hooks can be used to access url parameters and the history object
      hooks are not normal functions, and when using those we have to adhere to certain rules or limitations
         - Dont call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function.
         - Dont call Hooks from regular JavaScript functions
   Custom hooks
      the primary purpose of custom hooks is to facilitate the reuse of the logic used in components
      Custom hooks are regular JavaScript functions that can use any other hooks, as long as they adhere to the rules of hooks
      the name of custom hooks must start with the word use
      We implemented a counter application in part 1, that can have its value incremented, decremented, or reset
      extract the counter logic into its own custom hook
         Our custom hook uses the useState hook internally to create its own state
         The hook returns an object, the properties of which include the value of the counter as well as functions for manipulating the value
         we can extract the state of the App component and its manipulation entirely into the useCounter hook
         Managing the counter state and logic is now the responsibility of the custom hook
         The same hook could be reused in the application that was keeping track of the amount of clicks made to the left and right buttons
            The application creates two completely separate counters. The first one is assigned to the variable left and the other to the variable right
      Dealing with forms in React is somewhat tricky. Every field of the form has its own state and onChange handler 
      define our own custom useField hook, that simplifies the state management of the form
         The hook function receives the type of the input field as a parameter. The function returns all of the attributes required by the input: its type, value and the onChange handler.
   Spread attributes
      Since the name object has exactly all of the attributes that the input element expects, we can pass the props to the element using the spread syntax
      Dealing with forms is simplified when the unpleasant nitty-gritty details related to synchronizing the state of the form is encapsulated inside of our custom hook
      Custom hooks are clearly not only a tool for reuse, they also provide a better way for dividing our code into smaller modular parts.
   More about hooks
      sources worth checking out

...

c. More about styles
   Ready-made UI libraries
      One of the first widely popular UI frameworks was the Bootstrap
      Many UI frameworks provide developers of web applications with ready-made themes and "components" like buttons, menus, and tables
         we are not talking about React components
      Usually UI frameworks are used by including the CSS stylesheets and JavaScript code of the framework in the application
      There are many UI frameworks that have React-friendly versions, where the framework's "components" have been transformed into React components
         There are a few different React versions of Bootstrap like reactstrap and react-bootstrap
   React Bootstrap
         > npm install react-bootstrap
         add a link for loading the CSS stylesheet for Bootstrap inside of the head tag in the public/index.html file
         In Bootstrap, all of the contents of the application are typically rendered inside of a container
            this is accomplished by giving the root div element of the application the container class attribute
         make some changes to the Notes component, so that it renders the list of notes as a table. React Bootstrap provides a built-in Table component for this purpose
         React Bootstrap components have to be imported separately from the library
      Forms : React Bootstrap provides built-in components for creating forms
      Notification
         Store Notification in the message variable in the App component's state
         We will render the message as a Bootstrap Alert component
      Navigation structure : alter the application's navigation menu to use Bootstrap's Navbar component
      Bootstrap and a large majority of existing UI frameworks produce responsive designs
         meaning that the resulting applications render well on a variety of different screen sizes
         Chrome developer tools makes it possible to simulate using our application in the browser of different mobile clients:
   Material UI
      MaterialUI React library implements the Material design visual language developed by Google
      > npm install @material-ui/core
      add stylesheet line to the head tag in the public/index.html file. The line loads Google's font Roboto
      use MaterialUI to do the same modifications to the code we did earlier with bootstrap.
      do !!
   Closing thoughts
      The difference between react-bootstrap and MaterialUI is not big. It's up to you which one you find better looking
      Instead of using the React Bootstrap library, we could have just as well used Bootstrap directly by defining CSS classes to our application's HTML elements
      benefit of using React UI framework libraries is that they include the JavaScript that is needed to make specific components work
      UI libraries may have unstable API's and poor documentation
         Semantic UI React is a lot better than with many other UI frameworks, as it is an official React integration library
   Other UI frameworks
   Styled components
      The styled components library offers an interesting approach for defining styles through tagged template literals that were introduced in ES6
      > npm install styled-components
      Styled components have seen a consistent growth in popularity in recent times

d. Webpack
      One of the key players in making React applications functional is a tool called webpack
   Bundling
      We have implemented our applications by dividing our code into separate modules that have been imported to places that require them
         no browser actually knows how to handle code that is divided into modules
      code that is divided into modules must be bundled for browsers, 
         meaning that all of the source code files are transformed into a single file that contains all of the application code
         we performed the bundling of our application with the npm run build command to bundles the source code using webpack
         The index.html file located at the root of the build directory is the "main file" of the application, that loads the bundled JavaScript file with a script tag
         the build script also bundles the application's CSS files into a single


   .....

e. Class components, Miscellaneous
   Class Components
      During the course we have only used React components having been defined as Javascript functions
      This was not possible without the hook-functionality that came with version 16.8 of React
      Before, when defining a component that uses state one had to define it using Javascript's Class-syntax
      https://reactjs.org/docs/hooks-state.html
      It is beneficial to at least be familiar with Class Components to some extent, since the world contains a lot of old React code
      The component has a constructor and contains the method render
      In contrast to when using the useState-hook, Class Components only contain one state
         if the state is made up of multiple "parts" they should be stored as properties of the state. The state is initialized in the constructor
      The component state is in the instance variable this.state. 
         The state is an object having two properties. this.state.anecdotes is the list of anecdotes and this.state.current is the index of the currently shown anecdote
      In Functional components the right place for fetching data from a server is inside an effect hook
      The lifecycle-methods of Class Components offer corresponding functionality
         The correct place to trigger the fetching of data from a server is inside the lifecycle-method componentDidMount
         https://reactjs.org/docs/hooks-effect.html
         The callback function of the HTTP request updates the component state using the method setState
         Calling the method setState always trigger the rerender of the Class Component, i.e. calling the method render
      The biggest difference between Functional components and Class components 
         - the state of a Class component is a single object, and that the state is updated using the method setState
         - in Functional components the state can consist of multiple different variables, with all of them having their own update function.
      In some more advanced use cases the effect hook offers a considerably better mechanism for controlling side effects compared to the lifecycle-methods of Class Components.
      A notable benefit of using Functional components is not having to deal with the self referencing this-reference of the Javascript class.
      Class Components offer basically no benefits over Functional components enhanced with hooks, with the exception of the so-called error boundary mechanism
      When writing fresh code there is no rational reason to use Class Components if the project is using React with a version number 16.8 or greater
      On the other hand, there is currently no need to rewrite all old React code as Functional components.
   Organization of code in React application
      components, reducers, services directory fits a smaller application just fine
      as the amount of components increase, better solutions are needed. There is no one correct way to organize a project
         https://medium.com/hackernoon/the-100-correct-way-to-structure-a-react-app-or-why-theres-no-such-thing-3ede534ef1ed
   Frontend and backend in the same repository
      we have created the frontend and backend into separate repositories. However, we did the deployment by copying the bundled frontend code into the backend repository
      A possibly better approach would have been to deploy the frontend code separately
      Especially with applications created using create-react-app it is very straightforward thanks to the included buildpack
   Changes on the server
      If there are changes in the state on the server, the React-frontend we implemented will not notice these changes until the page reloads
      A similar situation arises when the frontend triggers a time-consuming computation in the backend
      How do we reflect the results of the computation to the frontend?
         - One way is to execute polling on the frontend, meaning repeated requests to the backend API e.g. using the setInterval-command.
         - A more sophisticated way is to use WebSockets, using which it is possible to establish a two-way communication channel between the browser and the server
            The browser has to define callback functions for situations when the server sends data about updating state using a WebSocket
            Instead of directly using the WebSocket API it is advisable to use the Socket.io-library
            In part 8 our topic is GraphQL that provides a nice mechanism for notifying clients when there are changes in the backend data
   Virtual DOM
      browsers provide a DOM API, using which the JavaScript running in the browser can modify the elements defining the appearance of the page
      When a software developer uses React they rarely or never directly manipulate the DOM. The function defining the React component returns a set of React-elements
      read !!
   On the role of React in applications
      React is primarily a library for managing the creation of views for an application
      READ !!
   React/node-application security
      OWASP, publishes an annual list of the most common security risks in Web-applications
      SKIP ...
   Current trends
      Typescript
      Server side rendering, isomorphic applications and universal code
      Progressive web apps
      Microservice architecture
      Serverless
   Useful libraries and interesting links
      ...

[PART 11]
CI/CD
Introduction to CI/CD
      Debugging code might be hard but debugging configurations is way harder
   Getting software to production
      Writing software is all well and good, but we need to deploy the software to production, i.e. give it to the real users.
         After that we need to maintain it, release new versions, and work with other people to expand that software.
      Many problems may arise when several developers are involved
         a code works just fine in one developer's machine but another developer can not even get it started
         If two developers are both working on changes and they haven't decided on a way to deploy to production, whose changes get deployed?
   Some useful terms
      Branches
         Git allows multiple copies, streams, or versions of the code to co-exist without overwriting each other. 
         Branches are useful when this environment becomes more complex. Each branch is effectively a copy of the main branch with some changes
         each developer can work on their own set of changes and not affect any other developer until the changes are ready.
      Pull request
         merging a branch back to the main branch of software is quite often happening using a mechanism called pull request
         Once the pull request is made or opened, another developer checks that all is ok and merges the PR
      Build
         preparing software to run on the platform where it's intended to run
         In part 7 we had a look at webpack for building a production version of a React or any other frontend JavaScript or TypeScript codebase.
      Deploy
         Deployment refers to putting the software where it needs to be for the end-user to use it.
         we'll develop a simple "deployment pipeline" that deploys each commit of your code automatically to Heroku if the committed code does not break anything.
         Deployments can be significantly more complex, especially if we add requirements such as "the software must be available at all times during the deployment" (zero downtime deployments) 
   What is CI?
      CI refers to merging developer changes to the main branch often. 
      We'd likely want to do some of these steps: lint, build, test, package, upload/deploy. This process should be strictly defined.
   Packaging and Deployment as a part of CI
      Packaging and especially deployment are sometimes not considered to fall under the umbrella of CI
         We'll add them in here because in the real world it makes sense to lump it all together. 
         The packaging is often an area where issues crop up in CI as this isn't something that's usually tested locally.
         